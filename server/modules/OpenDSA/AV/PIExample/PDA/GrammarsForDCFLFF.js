$(document).ready(function() {
  "use strict";
  var av_name = "GrammarsForDCFLFF";
  var av = new JSAV(av_name);
  var Frames = PIFRAMES.init(av_name);
  var config = ODSA.UTILS.loadConfig({ av_name: av_name }),
    interpret = config.interpreter,
    code = config.code;
  var goNext = false;

  //Frame 1
  av.umsg("Now we know that:<br/>All CFL can be generated by a CFG, and implemented by a NPDA.<br/>Not all CFL can be generated using a DPDA.<br/>So some CFG are associated with only non-deterministic PDAs. Nondeterminism gives us something more in terms of capability.");
  av.displayInit();

  //Frame 2
  av.umsg(Frames.addQuestion("q2"));
  av.step();

  //Frame 3
  av.umsg(Frames.addQuestion("q3"));
  av.step();

  //Frame 4
  av.umsg("Think of a PDA as a parsing device. No backtracking requires that we can make a decision at every step on what to do next. This is the same as knowing which grammar production comes next.");
  av.step();

  //Frame 5
  av.umsg("Clearly this is linear time when the grammar has been simplified (no unit productions), because every derivation step consumes an input character. Well ... except for λ productions. But we will see soon that these are not really a problem for linear-time processing.");
  av.step();

  //Frame 6
  av.umsg("$\\textbf{Top-down Parsing with Lookahead}$<br/>Start with the start symbol Scan left-to-right through the string. At each step, we want only to follow one rule when we look at the current character. Perhaps we don’t see a production for the current character, but instead pop something off the stack (λ production). This is why λ productions are still linear, if we don’t put too much on the stack when we process a character.");
  av.step();

  //Frame 7
  av.umsg("$\\textbf{S-grammars}$<br/>Recall that an S-grammar has all productions of the form: $A \\rightarrow ax$ where $A \\in V$, $a\\in T$, and $x\\in V^*$ and AND any pair $(A,a)$ can occur in at most one rule.");
  av.step();

  //Frame 8
  av.umsg("$\\textbf{S-grammars}$<br/>Recall that an S-grammar has all productions of the form: $A \\rightarrow ax$ where $A \\in V$, $a\\in T$, and $x\\in V^*$ and AND any pair $(A,a)$ can occur in at most one rule.<br/>Obviously this can be parsed efficiently. But, s-grammars are more restrictive than we want. Lots of useful language constructs cannot be defined using an s-grammar. We want to generalize as much as we can to capture a broader subset of CFLs");
  av.step();

  //Frame 9
  av.umsg("$\\textbf{LL(k) Grammars}$<br/>LL means “left-to-right” and “left-most derivation” is constructed. $k$ means that we can look ahead at most $k−1$ characters. Every s-grammar is LL, but so are more grammars.");
  av.step();

  //Frame 10
  av.umsg(Frames.addQuestion("q10"));
  av.step();

  //Frame 11
  av.umsg(Frames.addQuestion("q11"));
  av.step();

  //Frame 12
  av.umsg(Frames.addQuestion("q12"));
  av.step();

  //Frame 13
  av.umsg("$\\textbf{LL(k) Grammars}$<br/>LL means “left-to-right” and “left-most derivation” is constructed. $k$ means that we can look ahead at most $k−1$ characters. Every s-grammar is LL, but so are more grammars.<br/>Consider this grammar $S \\rightarrow SS \\mid aSb \\mid ab$ This is a useful grammar! It captures nested parentheses. This is not an $LL(k)$ grammar for any $k$");
  av.step();

  //Frame 14
  av.umsg("Just because the grammar is not $LL(k)$ does not mean that the language might not be deterministic. The reasoning for why this was not $LL(k)$ should help you to see how to fix the grammar.");
  av.step();

  //Frame 15
  av.umsg(Frames.addQuestion("q15"));
  av.step();

  //Frame 16
  av.umsg(Frames.addQuestion("q16"));
  av.step();

  //Frame 17
  av.umsg("As you see, reading only one letter can tell us every time which production we need to use. That is why we call that grammar $LL(K)$ grammar.");
  av.step();

  //Frame 18
  av.umsg(Frames.addQuestion("q18"));
  av.step();

  av.umsg("Completed.")
  av.recorded();
});