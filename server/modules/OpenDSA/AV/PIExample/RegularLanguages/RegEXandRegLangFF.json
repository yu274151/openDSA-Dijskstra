{
    "translations": {
      "en": {
        "q3": {
          "type": "select",
          "description": "So why yet another representation? A good answer is that the other two representations are deficient (in different ways) that the regular expression overcomes.",
          "question":"What do we mean by the other two?",
          "answer": ["NFA", "DFA"],
          "choices": ["NFA", "DFA", "English Description"]
        },
        "q4": {
          "type": "select",
          "description": "Describing it in English is imprecise. Even if we use math to make it precise, its something that we cannot easily operationalize. On the other hand, defining a DFA (or NFA) is a bit time consuming.",
          "question":"Why do we say NFA or DFA?",
          "answer": ["NFA and DFA are equivalent", "We can convert any one to the other one"],
          "choices": ["NFA and DFA are equivalent", "We can convert any one to the other one"]
        },
        "q6": {
          "type": "select",
          "description": "In contrast, we can type out a regular expression within systems like JFLAP and OpenFLAP. In that case, it is both fast to type and operationalizeable (in the sense that we can then convert the RegEx to a DFA, which implements the acceptor for the regular expression).",
          "question":"Why RegEx is the best solution to represent a Language?",
          "answer": ["Fast to type", "There are tools to convert RegEx to DFA and NFA"],
          "choices": ["Fast to type", "There are tools to convert RegEx to DFA and NFA", "RegEx can represent more languages"]
        },
        "q8": {
          "type": "select",
          "description": "Recall that we $\\textbf {define}$ the term $\\textbf {regular language}$ to mean the languages that are recognized by a DFA. (Which we know is the same as the languages recognized by an NFA, because we know that every NFA can be converted to a DFA).",
          "question":"Regular Languages are languages that can be",
          "answer": ["Accepted by DFA", "Accepted by NFA"],
          "choices": ["Accepted by DFA", "Accepted by NFA"]
        },
        "q9": {
          "type": "multiple",
          "description": "How do regular expressions relate to DFA and NFA? <br/>Are they the same languages? <br/>Is one a subset of the other? <br/>Or are they just different collections of languages?",
          "question":"What do you think?",
          "answer": "RegEx, DFA, and NFA represent the languages",
          "choices": ["RegEx, DFA, and NFA represent the languages", "One of them is a subset of the others","RegEx, NFA, and DFA are just different collections of languages"]
        },
        "q11": {
          "type": "select",
          "description": "Here is an example of NFA that accepts nothing ($\\emptyset$)",
          "question":"This machine accepts NOTHING because there is no path from the start state to the final state",
          "answer": "True",
          "choices": []
        },
        "q12": {
          "type": "multiple",
          "description": "Here is an example of NFA that accepts an empty string ($\\lambda$)",
          "question":"Can we build a DFA with one state to accept $\\lambda$?",
          "answer": "Yes, a DFA/NFA with one state that is both start and final",
          "choices": ["Yes, a DFA/NFA with one state that is both start and final", "No"]
        },
        "q13": {
          "type": "multiple",
          "description": "Here is an example of NFA that accepts $a$ $\\in$ $\\Sigma$",
          "question":"Can we build a DFA with one state to accept $a$?",
          "answer": "No",
          "choices": ["Yes, a DFA/NFA with one state that is both start and final, and a looping transition with $a$", "No"]
        },
        "q17": {
          "type": "multiple",
          "description": "And since we want to combine machines together, it will be much easier if we know that the arbitrary machine has one start state and one final state. Well, we already know that all NFAs have a single start state. But not all NFAs have a single final state.",
          "question":"Can we covert any NFA with multiple final states to an equivalent NFA with single NFA?",
          "answer": "Yes",
          "choices": ["Yes", "No"]
        },
        "q18": {
          "type": "multiple",
          "description": "Consider any NFA, and its various final states. Is there an easy way to convert this to an equivalent NFA with a single final state? The answer is 'yes'",
          "question":"How?",
          "answer": "by adding a new state that will be the final state for the machine.",
          "choices": ["by adding a new state that will be the final state for the machine.", "Convert NFA to DFA"]
        },
        "q19": {
          "type": "select",
          "description": "Consider any NFA, and its various final states. Is there an easy way to convert this to an equivalent NFA with a single final state? The answer is 'yes'",
          "question":"Then we need to connect all old final states with the new final state with $\\lambda$ transitions",
          "answer": "True",
          "choices": []
        },
        "q20": {
          "type": "select",
          "description": "Consider any NFA, and its various final states. Is there an easy way to convert this to an equivalent NFA with a single final state? The answer is 'yes'",
          "question":"Then we need to remove the final mark from the old final states",
          "answer": "True",
          "choices": []
        },
        "q21": {
          "type": "multiple",
          "description": "You did it.",
          "question":"Is the new NFA is equivalent to the old NFA?",
          "answer": "Yes",
          "choices": ["Yes", "No"]
        }
      }
    }
  }
  