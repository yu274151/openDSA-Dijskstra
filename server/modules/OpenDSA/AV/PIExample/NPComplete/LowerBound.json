{
  "translations": {
    "en": {
      "q1": {
        "type": "multiple",
        "description":"<b>Reduction and Finding Lower Bound</b><br><br>There is another use of reductions aside from applying an old algorithm to solve a new problem (and thereby establishing an upper bound for the new problem). That is to prove a lower bound on the cost of a new problem by showing that it could be used as a solution for an old problem with a known lower bound.",
        "question":"Is it true that we can prove a lower bound on the cost of a new problem by showing that it could be used as a solution for an old problem with a known lower bound?",
        "answer": "Yes",
        "choices": ["Yes", "No"]
      },
      "q2": {
        "type": "multiple",
        "description":"<br>To complete this proof regarding the lower bound for PAIRING, we need now to find a way to reduce SORTING to PAIRING. This is easily done. Take an instance of SORTING (i.e., an array A of n elements). A second array B is generated that simply stores i in position i for 0 ≤ i < n. Pass the two arrays to PAIRING. <br><br> Take the resulting set of pairs, and use the value from the B half of the pair to tell which position in the sorted array the A half should take; that is, we can now reorder the records in the A array using the corresponding value in the B array as the sort key and running a simple Θ(n) Binsort. The conversion of SORTING to PAIRING can be done in O(n) time, and likewise the conversion of the output of PAIRING can be converted to the correct output for SORTING in O(n) time. Thus, the cost of this sorting algorithm is dominated by the cost for PAIRING.",
        "question":"The lower bound for SORTING in the worst and average cases is in Ω(nlogn). If we convert SORTING to PAIRING fast enough, is it true that PAIRING have a lower bound in Ω(nlogn)?",
        "answer": "Yes",
        "choices": ["Yes", "No"]
      },
      "q31": {
        "type": "select",
        "description":"<b>The Reduction Template</b> <br> <br>Consider any two problems for which a suitable reduction from one to the other can be found. The first problem takes an arbitrary instance of its input, which we will call I, and transforms I to a solution, which we will call SLN. The second problem takes an arbitrary instance of its input, which we will call I', and transforms I' to a solution, which we will call SLN'. We can define reduction more formally as a three-step process:",
        "question":"which of the follwing is true",
        "answer":  ["SLN is the solution of I", "SLN must be the correct solution for I for the reduction to be acceptable"],
        "choices": ["the transformation from any instance I of the first problem to an instance I' of the second problem is not necessary", "SLN is the solution of I", "SLN must be the correct solution for I for the reduction to be acceptable", "SLN' is not the solution of I'"]
      },
      "q32": {
        "type": "multiple",
        "description":"<br>It is important to note that the reduction process does not give us an algorithm for solving either problem by itself. It merely gives us a method for solving the first problem given that we already have a solution to the second. More importantly for the topics to be discussed in the remainder of this chapter, reduction gives us a way to understand the bounds of one problem in terms of another. Specifically, given efficient transformations, the upper bound of the first problem is at most the upper bound of the second. Conversely, the lower bound of the second problem is at least the lower bound of the first.",
        "question":"Is it true that the reduction process give us an algorithm for solving either problem by itself?",
        "answer": "No",
        "choices": ["Yes", "No"]
      },

      "q33": {
        "type": "select",
        "description":"<br>It is important to note that the reduction process does not give us an algorithm for solving either problem by itself. It merely gives us a method for solving the first problem given that we already have a solution to the second. More importantly for the topics to be discussed in the remainder of this chapter, reduction gives us a way to understand the bounds of one problem in terms of another. Specifically, given efficient transformations, the upper bound of the first problem is at most the upper bound of the second. Conversely, the lower bound of the second problem is at least the lower bound of the first.",
        "question":"which of the follwing is true",
        "answer":  ["the upper bound of the first problem is at most the upper bound of the second", "the lower bound of the second problem is at least the lower bound of the first", "reduction gives us a way to understand the bounds of one problem in terms of another"],
        "choices": ["the upper bound of the first problem is at most the upper bound of the second", "the lower bound of the second problem is at least the lower bound of the first", "reduction gives us a way to understand the bounds of one problem in terms of another"]
      }

    }
  }
}

